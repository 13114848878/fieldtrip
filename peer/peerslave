#!/bin/bash
# requires bash, because of array use and for (( )) construct 
#
# helper script to start multiple peers in slave mode

#where are these functions used?
#if [[ -e /etc/rc.d/init.d/functions ]]; then 
#source /etc/rc.d/init.d/functions
#fi

if [[ "$USER" == "public" ]]; then
 umask 0000
fi

PLATFORM=$(gcc -dumpmachine)
HOSTNAME=$(hostname -s)

case "$PLATFORM" in
x86_64-redhat-linux)
	MATLABARCH=glnxa64
	if [ -e /opt/matlab77 ] ; then
	MATLABPATH=/opt/matlab77
	MATLABCMD='"/opt/cluster/matlab77 -nodisplay -singleCompThread"'
	else
	MATLABPATH=/opt/matlab-2009b
	MATLABCMD='"/opt/bin/matlab -nodisplay -singleCompThread"'
	fi
	;;
i386-redhat-linux)
	MATLABARCH=glnx86
	MATLABPATH=/opt/matlab75
	MATLABCMD=/opt/cluster/$(basename $MATLABPATH)
	;;
*)
	echo error: error unknown architecture and platform >&2
	exit 1
	;;
esac

EXECDIR=$(dirname $0)
export LD_LIBRARY_PATH=$MATLABPATH/bin/$MATLABARCH/ 

##############################################################################
# machine definitions
##############################################################################
# 512MB =  536870912
# 1GB   = 1073741824
# 2GB   = 2147483648 
# 4GB   = 4294967296 
# 8GB   = 8589934592 

GIB1=1073741824
GIB2=2147483648
GIB4=4294967296
GIB8=8589934592

TIM_TENMIN=$((10*60-1))
TIM_HOUR=$((60*60-1))
TIM_DAY=$((3600*24-1))

#determine the number of cpu's (not counting hyperthreading ones)
#assuming all physical packages are equal
NUMCPU=$(cat /proc/cpuinfo | awk '
/physical id/ {
	maxpackage = $4 > maxpackage ? $4 : maxpackage
	}
/cpu cores/ {cpucores = $4}
END {
	print (1+maxpackage)*cpucores
}')

#load default values per cpu core
memavail=( $( for i in $(seq $NUMCPU); do echo "auto" ; done) )
timavail=( $( for i in $(seq $NUMCPU); do echo $TIM_DAY ; done) )

case "$HOSTNAME" in 
mentat001|mentat002)
	# has 16GB of RAM, 2 CPUs and 4 cores in total
	# Dual Core AMD Opteron(tm) Processor 270
	timavail[0]=$TIM_DAY
	timavail[1]=$TIM_HOUR
	timavail[2]=$TIM_HOUR
	timavail[3]=$TIM_TENMIN
	OPTIONS="--verbose 4 --smartcpu 1"
	;;
mentat003|mentat004)
	# has 32GB of RAM, 2 CPUs and 8 cores in total
	# Intel(R) Xeon(R) CPU E5520 @ 2.27GHz
	OPTIONS="--verbose 4 --smartcpu 1"
	;;
mentat005)
	# has 48GB of RAM, 2 CPUs and 12 cores in total
	memavail=( $( for i in $(seq $NUMCPU); do echo $GIB4 ; done) )
	timavail=( $( for i in $(seq 8); do echo $TIM_DAY ; done) )
	timavail=( ${timavail[@]} $( for i in $(seq 4); do echo $TIM_HOUR ; done) )
	OPTIONS="--verbose 4 --smartcpu 0"
	;;
mentat068|mentat069)
	# this is an old 32 bit machine which has 4GB of RAM, a single CPU with a single core
	# Intel(R) Pentium(R) 4 CPU 3.20GHz
	timavail[0]=$TIM_TENMIN
	OPTIONS="--verbose 4 --smartcpu 0"
	;;
mentat2??)
	# has 8GB-12GB of RAM, one CPU and 4 cores
	# Intel(R) Core(TM)2 Quad CPU Q9550 @ 2.83GHz
	timavail=($TIM_DAY $TIM_HOUR $TIM_HOUR $TIM_TENMIN)
	OPTIONS="--verbose 4 --smartcpu 1"
	;;
manzana)
	# Mac OS X computer with 10B of RAM, two CPUs and 4 cores
	# Dual-Core Intel Xeon 2.66 GHz
	timavail=( $( for i in $(seq 4); do echo $TIM_DAY ; done) )
	OPTIONS="--verbose 4 --smartcpu 0"
	;;
esi-hpc1-1)
	# has 48GB of RAM, 2 CPUs and 12 cores in total, this one also serves as the head node
	memavail=( $( for i in $(seq $NUMCPU); do echo $GIB4 ; done) )
	timavail=( $TIM_HOUR $TIM_HOUR $TIM_TENMIN $TIM_TENMIN )
	OPTIONS="--verbose 4 --smartcpu 1"
	;;
esi-hpc1-[2-9]|esi-hpc1-10)
	# has 48GB of RAM, 2 CPUs and 12 cores in total
	memavail=( $GIB8    $GIB8    $GIB8       $GIB4    $GIB4    $GIB4       $GIB2    $GIB2)
	timavail=( $TIM_DAY $TIM_DAY $TIM_TENMIN $TIM_DAY $TIM_DAY $TIM_TENMIN $TIM_DAY $TIM_TENMIN )
	OPTIONS="--verbose 4 --smartcpu 1"
	;;
*)
	# the default configuration for all other machines is a single peerslave 
	unset timavail
	unset memavail
	memavail=( auto )
	timavail=( $TIM_DAY )
	;;
esac

##############################################################################
# functions
##############################################################################

function check_process_running {
	pid=$1
	procname=$2
	if [ -d /proc/$pid ]
	then
		if grep -- "$procname" /proc/$pid/cmdline >/dev/null 2>&1
		then
			return 0
		fi
	fi
	return 1
}

function start_peerslave {
	MEMAVAIL=$1
	TIMAVAIL=$2
	SLAVENUM=$3
	if [[ -z "$MEMAVAIL" ]] ; then
		MEMAVAIL=auto
	fi
	if [[ -z "$TIMAVAIL" ]] ; then
		TIMAVAIL=$TIM_HOUR
	fi
	if [[ -z "$SLAVENUM" ]] ; then
		SLAVENUM=0
	fi

	EXECUTABLE=$EXECDIR/peerslave.$MATLABARCH
	if [ ! -e $EXECUTABLE ] ; then
		echo error: could not locate peerslave command-line executable >&2
		exit 1
	fi

	# note that all spaces in the full matlab startup command have to be in ''
	if [[ "$1" = "auto" ]] ; then
		PEEROPTIONS="$OPTIONS --smartmem 1               --timavail $2"
	else
		PEEROPTIONS="$OPTIONS --smartmem 0 --memavail $1 --timavail $2"
	fi

	PIDFILE=$PIDDIR/peerslave.$SLAVENUM
	eval $EXECUTABLE $PEEROPTIONS --matlab "$MATLABCMD" &
	PID=$!
	if check_process_running $PID peerslave  ; then
		echo -n $PID > $PIDFILE
	else
		echo warning: failed to start peerslave $SLAVENUM
	fi
}


##############################################################################
# execution
##############################################################################

PIDDIR=/tmp/run.$USER
mkdir -p $PIDDIR

COMMAND=$1
case $COMMAND in
start)
	# start all peerslaves
	for ((index=0; index < ${#memavail[@]}; index++))
	do
		PIDFILE=$PIDDIR/peerslave.$index
		if [[ -e $PIDFILE ]] ; then
			if check_process_running $(cat $PIDFILE) peerslave ; then
				echo "peerslave still running" >/dev/null
			else
				# the process is not running any more
				echo starting peerslave number $index
				start_peerslave ${memavail[$index]} ${timavail[$index]} $index
			fi
		fi
	done
;;


status)
	for ((index=0; index < ${#memavail[@]}; index++))
	do
		if [[ -e $PIDFILE ]] ; then
			PEERPID=$(cat $PIDFILE)
			if check_process_running $PEERPID peerslave ; then
				echo peerslave $index is running with pid $PEERPID
			else
				# the process is not running any more
				echo peerslave $index seems to have stopped running
			fi
		else
			# the process is not running any more
			echo peerslave $index is not running
		fi
	done
;;

stop)
	# find the pid of each peerslave and kill it
	for ((index=0; index < ${#memavail[@]}; index++))
	do
		PIDFILE=$PIDDIR/peerslave.$index
		if [[ -e $PIDFILE ]] ; then
			PEERPID=$(cat $PIDFILE)
			if [[ -e /proc/$PEERPID ]] ; then
				echo stopping peerslave number $index
				rm -f $PIDFILE
				kill $PEERPID
			else
				# the process is not running any more
				rm -f $PIDFILE
			fi
		else
			# the process is not running any more
			echo -n
		fi
	done
;;

restart)
	$0 stop
	$0 start
;;

kill)
	killall -q peerslave.$MATLABARCH
	killall -q MATLAB
	rm -f $PIDDIR/peerslave.[0-9]
	rm -f $PIDDIR/peerslave.[0-9][0-9]
	rm -f $PIDDIR/peerslave.[0-9][0-9][0-9]
;;

*)
	# just start a single peerslave, pass the user's arguments
	EXECUTABLE=$EXECDIR/peerslave.$MATLABARCH
	$EXECUTABLE "$@"

;;
esac

